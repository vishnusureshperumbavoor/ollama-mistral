var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as utils from './utils.js';
import fs, { promises, createReadStream } from 'fs';
import { join, resolve, dirname } from 'path';
import { createHash } from 'crypto';
import { homedir } from 'os';
import { Ollama as OllamaBrowser } from './browser.js';
export class Ollama extends OllamaBrowser {
    encodeImage(image) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof image !== 'string') {
                // image is Uint8Array or Buffer, convert it to base64
                const result = Buffer.from(image).toString('base64');
                return result;
            }
            try {
                if (fs.existsSync(image)) {
                    // this is a filepath, read the file and convert it to base64
                    const fileBuffer = yield promises.readFile(resolve(image));
                    return Buffer.from(fileBuffer).toString('base64');
                }
            }
            catch (_a) {
                // continue
            }
            // the string may be base64 encoded
            return image;
        });
    }
    parseModelfile(modelfile, mfDir = process.cwd()) {
        return __awaiter(this, void 0, void 0, function* () {
            const out = [];
            const lines = modelfile.split('\n');
            for (const line of lines) {
                const [command, args] = line.split(' ', 2);
                if (['FROM', 'ADAPTER'].includes(command.toUpperCase())) {
                    const path = this.resolvePath(args.trim(), mfDir);
                    if (yield this.fileExists(path)) {
                        out.push(`${command} @${yield this.createBlob(path)}`);
                    }
                    else {
                        out.push(`${command} ${args}`);
                    }
                }
                else {
                    out.push(line);
                }
            }
            return out.join('\n');
        });
    }
    resolvePath(inputPath, mfDir) {
        if (inputPath.startsWith('~')) {
            return join(homedir(), inputPath.slice(1));
        }
        return resolve(mfDir, inputPath);
    }
    fileExists(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield promises.access(path);
                return true;
            }
            catch (_a) {
                return false;
            }
        });
    }
    createBlob(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof ReadableStream === 'undefined') {
                // Not all fetch implementations support streaming
                // TODO: support non-streaming uploads
                throw new Error('Streaming uploads are not supported in this environment.');
            }
            // Create a stream for reading the file
            const fileStream = createReadStream(path);
            // Compute the SHA256 digest
            const sha256sum = yield new Promise((resolve, reject) => {
                const hash = createHash('sha256');
                fileStream.on('data', (data) => hash.update(data));
                fileStream.on('end', () => resolve(hash.digest('hex')));
                fileStream.on('error', reject);
            });
            const digest = `sha256:${sha256sum}`;
            try {
                yield utils.head(this.fetch, `${this.config.host}/api/blobs/${digest}`);
            }
            catch (e) {
                if (e instanceof Error && e.message.includes('404')) {
                    // Create a new readable stream for the fetch request
                    const readableStream = new ReadableStream({
                        start(controller) {
                            fileStream.on('data', (chunk) => {
                                controller.enqueue(chunk); // Enqueue the chunk directly
                            });
                            fileStream.on('end', () => {
                                controller.close(); // Close the stream when the file ends
                            });
                            fileStream.on('error', (err) => {
                                controller.error(err); // Propagate errors to the stream
                            });
                        },
                    });
                    yield utils.post(this.fetch, `${this.config.host}/api/blobs/${digest}`, readableStream);
                }
                else {
                    throw e;
                }
            }
            return digest;
        });
    }
    create(request) {
        const _super = Object.create(null, {
            create: { get: () => super.create }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let modelfileContent = '';
            if (request.path) {
                modelfileContent = yield promises.readFile(request.path, { encoding: 'utf8' });
                modelfileContent = yield this.parseModelfile(modelfileContent, dirname(request.path));
            }
            else if (request.modelfile) {
                modelfileContent = yield this.parseModelfile(request.modelfile);
            }
            else {
                throw new Error('Must provide either path or modelfile to create a model');
            }
            request.modelfile = modelfileContent;
            // check stream here so that typescript knows which overload to use
            if (request.stream) {
                return _super.create.call(this, request);
            }
            else {
                return _super.create.call(this, request);
            }
        });
    }
}
export default new Ollama();
// export all types from the main entry point so that packages importing types dont need to specify paths
export * from './interfaces.js';
